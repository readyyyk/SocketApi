const WS_CLOSE_NORMAL=1e3,WS_CLOSE_GOING_AWAY=1001;class SocketApi{link="";dataCheckers=new Map;eventListeners=new Map;isRefreshable=!1;refreshDelay=500;idleTimeoutId;unemitted=[];constructor(link=`ws://${location.host}`){this.link=link,this.initSocket(link)}initSocket(link){this.socket=new WebSocket(link),this.socketHandler=eventFetched=>{const{event:event,data:data}=JSON.parse(eventFetched.data);this.eventListeners.has(event)?this.eventListeners.get(event)(JSON.parse(data)):console.error(`[WS] - No listener specified for event ('${event}')`)},this.socket.onmessage=this.socketHandler,this.isRefreshable&&this.makeRefreshable()}makeRefreshable(delay=this.refreshDelay,maxIdleTime=1e3){this.isRefreshable=!0,this.socket.onclose=ev=>![WS_CLOSE_NORMAL,WS_CLOSE_GOING_AWAY].includes(ev.code)&&setTimeout((()=>this.initSocket(this.link)),delay),document.onvisibilitychange=()=>{document.hidden?this.idleTimeoutId=setTimeout((()=>this.socket.close(WS_CLOSE_NORMAL,"tab idle")),maxIdleTime):clearTimeout(this.idleTimeoutId)},console.info("Reconnected")}addDataChecker(event,checkerFunc=function(a){return!1}){!event instanceof String?console.error("[WS] - Event must be a `string`"):!event instanceof Function?console.error("[WS] - New data checker must be a `Function`"):this.dataCheckers.set(event,checkerFunc)}on(event,handlerFunc){!event instanceof String?console.error("[WS] - New event must be a `string`"):!event instanceof Function?console.error("[WS] - New event handler must be a `Function`"):this.eventListeners.set(event,handlerFunc)}waitForSocket(){return new Promise((resolve=>{this.socket.readyState?resolve():(console.warn("[WS] - Waiting for socket connection..."),this.socket.onopen=()=>resolve())}))}emit(event="default",data={}){if(!event instanceof String)console.error("[WS] - event must be a `String`!");else{if(this.dataCheckers.has(event)){if(!this.dataCheckers.get(event)(data))return void console.error("[WS] - Data is not verified!","\nevent: ",event,"\ndata: ",data)}else console.warn(`[WS] No data checker provided for event! (event: ${event})`);this.socket.readyState||this.unemitted.push({event:event,data:data}),this.waitForSocket().then((()=>{if(this.unemitted.length){const unemittedData=this.unemitted.shift();event=unemittedData.event,data=unemittedData.data}this.socket.send(JSON.stringify({event:event,data:JSON.stringify(data)})),this.unemitted.length&&this.emit(this.unemitted[0].event,this.unemitted[0].data)}))}}}